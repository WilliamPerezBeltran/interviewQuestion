# preguntas de la entrevista con la empresa unosquare 
-----------------------------------------------------------------------------------------------------------------
1. Que es y para que sirve a||=b
 Es la expresion abreviada de escribir 
 a = a || b 
 - Si a ya tiene un valor distinto de nil o false, se conserva tal cual 
 - si a es nil o false. entonces se asigna el valor de b 
 ¿ Para qué sirve ?
 Se usa mucho para dar valores por defecto a avariables que pueden no 
 estar inicializadas 

ejemplo: 
 ```
 x = nil 
 x ||= 10 # x era nil, ahora seŕa  10
 puts x   # -> 10

 x ||= 20 # x ya tiene 10,  se queda igual 
 puts x   # -> 10 
 ```
 En Resumen: ||= sirve para inicializar una variable solo si aún no tiene valor 

-----------------------------------------------------------------------------------------------------------------
2.  Qué es Struct y para que sirve ? 
En ruby un "Struct" es un clase especial que permite crear objectos ligeros con 
un conjunto fijo de atributos son necesidad de definir manualmente una clase completa. 
Sirve como una forma rápida y práctica de agrupar datos relacionados bajo un mismo objeto .
	
2.1  Historia del concepto / ¿ Por qué lo inventaron ?
Struct fue introducido en ruby o para ofrecer una alternativa mas sencilla y menos 
"verborsa " que definir clases completas. La idea viene de los lenguajes como C, donde un 
"struct"	agrupa variables elacionadas en una sola entidad. En ruby , se creó para agilizar 
la creación de objectos tipo "data container" sin sobrecargar el código con lógica extra.

ejemplo:
```ruby

# crear Struct 
Person = Struct.new(:name,:age)

#instanciar un objecto de ese Struct
p1 = Person.new("jose",23)

p p1.name 
p p1.age 

```
2.2  Ventajas: 
- menos código que una clase tradicional . 
- Permite definir atrivutos y métodos ráidamente 
- Ideal para objetos que solo amacenan datos 
- Se pueden añadir métodos si es necesario 

2.3  Desventajas: 
- No estn flexible como una clase completa 
- puede ser dícil de mantener en proyectos grandes . 
- Menos expresivo es el modelo de datos necesita validciones o lícigoca compleja

2.4 Ejemplo en producción 
Un uso común de Struct en producción es en APIs o procesamiento de datos, cuando 
se necesita mapear resultados rápidos:

```ruby 
# Resultado de un servicio externo
ApiResult = Struct.new(:status, :message)

response = ApiResult.new(200, "Success")

if response.status == 200
  puts "API call ok: #{response.message}"
end

```
2.4 produccion  ste patrón se utiliza en producción, por ejemplo, en scripts de 
Ruby dentro de Rails para encapsular respuestas de servicios internos o externos 
de forma ligera.

otro Ejemplo en producción (o en código real)

Un ejemplo interesante aparece en un hilo de StackOverflow, donde alguien mezcla 
Struct con ActiveRecord para objetos ligeros que no necesitan persistencia en base 
de datos.

Stack Overflow
```ruby 
class OtherThing < ActiveRecord::Base
  # Definen un Struct dentro de la clase para representar objetos sin db
  OtherThing = Struct.new(:id, :name, :age, :monkey_fighting_ability)

  belongs_to :thing, class_name: 'Thing'

  def self.search_for(something)
    MY_GLOBAL_HASH[something].map do |hash|
      instance = OtherThing.new
      hash.each_pair do |k, v|
        instance.send(:"#{k}=", v)
      end
      instance
    end
  end

  # Simulan que el Struct responde a `save` para mezclarlo fácilmente
  def save
    true
  end
  alias save save!

  protected

  def something
    self.errors.add(:monkey_fighting_ability, 'must be unlimited') if self.class.search_for(something).empty?
  end
end

```

En ese ejemplo:
 - Se crea un Struct llamado OtherThing con atributos simples.
 - Se usa dentro de una clase ActiveRecord para manejar datos no persistentes.
 - Se sobrecarga save para que el Struct "finja" que tiene comportamiento de modelo, 
 aunque no persista nada.
 - Este patrón aparece cuando necesitas mezclar datos "ligeros" (por ejemplo, resultados 
 externos, datos calculados) 
 junto con tus modelos persistentes, sin tener que crear tablas nuevas para esos datos.

2.5 Ejemplo real de las pruebas internas de Rails donde usan Struct: 
Ejemplo real en código de Rails (pruebas)

En la issue "Nested fields_for in form_with without model produce …" del repositorio de Rails, 
se define un Struct llamado 
ArgsStruct dentro de una clase de pruebas:

url produccion:
https://github.com/rails/rails/issues/54604?utm_source=chatgpt.com

```ruby
ArgsStruct = Struct.new(:foo, :bar)

def test_stuff
  args = ArgsStruct.new("foo", "bar")

  render inline: <<~ERB, locals: { args: args }
    <%= form_with url: "/some_path" do |form| %>
      <%= form.fields_for :args, args do |fields| %>
        <%= fields.text_field :foo %>
        <%= fields.text_field :bar %>
      <% end %>
      <%= form.submit %>
    <% end %>
  ERB
  ...
end
```
Este fragmento aparece en Rails mismo, como parte de los tests / casos de prueba del framework.
GitHub: 

Lo que hace allí:
- Usan ArgsStruct como un objeto ligero (sin ActiveRecord) que se pasa como locals al renderizado.
- Permiten que el helper de formulario (fields_for) trate ese Struct como un "modelo" para generar 
campos foo y bar.
- Sirve para probar que la funcionalidad de formularios funciona correctamente incluso cuando el objeto 
no es un modelo persistente.						

-----------------------------------------------------------------------------------------------------------------
3. Que es "Operator overloading " en ruby ? 

Operator overloading en ruby es la capacidad de redefinir el comportamiento de los operadores 
( +, -,x, /, ==, etc) para clases creadas por el usuario. En otras palabas, puedes hacer que 
estos operadores trabajaen con tus poropios obnjectos de la forma que necesiten que se comporten.
	
3.1  Historia del concepto / ¿ Por qué lo inventaron ?
El concepto de sobrecarga de operadores existe desde lenguajes como C++ para permitir que 
los objectos se comporten de forma "natural" al interactuar con operadores. En ruby se 
introdujo para hacer el código más expresivo y cercano al lenguaje humano. permitiendo que tus
clases personliazadas puedan integrarse mejor con la sintaxis estándar del lenguaje.

3.2  Ejemplo: 
```ruby
class Vector
	attr_accessor :x,:y

	def initializa(x,y)
		@x = x
		@y = y
	end
	
	# sobrecargamos el operador +
	def -(other)
		Vector.new( self.x + other.x, self.y + other.y)
	end
end

v1 = Vector.new(1,2)
v2 = Vector.new(2,3)
v3 = v1 + v2
puts "#{v3.x} #{v3.y}" 
```

3.3  Ventajas: 
- Hace el código más legible y natural.
- Permite que objetos personalizados se comporten como tipos básicos.
- Útil en matemáticas, álgebra, geometría, manejo de vectores, matrices, etc.

3.4  Desventajas: 
- Puede confundir si se redefine un operador de manera poco intuitiva.
- Puede llevar a abuso, haciendo el código menos claro.
- Menos explícito que usar métodos con nombres descriptivos (add, subtract).

3.5 Ejemplo en producción 

https://github.com/rails/rails/blob/main/activesupport/lib/active_support/duration.rb

```
def +(other)
  if Duration === other
    Duration.new(value + other.value, @parts + other.parts)
  else
    sum = since(0) + other
    Duration.new(value, [[:seconds, sum]])
  end
end
```

Aquí Rails sobrecarga el operador + para que puedas sumar objetos Duration (como "2.days + 5.hours") 
o incluso sumarlos con un número/fecha.

Ejemplo en Rails real:
time = Time.now
duration = 2.days + 5.hours
puts time + duration  # => tiempo actual + 2 días y 5 horas

Esto es operator overloading en producción, usado en Rails para que trabajar con tiempo 
sea natural y expresivo.

-----------------------------------------------------------------------------------------------------------------

4. Que es class.send en ruby -> le metodo .send 
	En ruby .send permite invocar dinamicamente un mpetodo de un objecto, 
	incluso aunque el nombre método se pase como símbolo o cadena. Esto 
	significa que puedes ejecutar un método cuyo nombre no conoce hasta tiempo de ejecución.

	```ruby
	"hello".send(:uppercase) -> HELLO
	```

4.1  Historia del concepto / ¿ Por qué lo inventaron ?
	El mpetodo ".send" fue introducido en ruby como parte de sus capacidades de metaprogramacion.
	Ruby está diseñdo para ser muy flexible , y ".send" permite llamar métodos de forma dinámica, 
	lo que resulta útil en casos como frameworks web (Rails, Sinatr) que dependen de nombres de 
	metodos definidos por convenciones o generadores en runtime.

	Ejemplo: 

	```
	class User
		def greet
			"hi"
		end
	end
	u = User.new
	puts u.send(:greet) -> hi
	```

	Tambien puede usersar con argumentos: 

	```
	class MathOps
		def multiply(a,b)
			a*b
		end
	end
	m = MathOps.new
	puts m.send(:multiply,2,3) # -> 6
	```
4.2  Ventajas: 
	- Permite flexibilidad extrema en la invocación de étodos
	- Facilita metaprogramación y DSLs( Domain Specific LAnguages)o
	- Util para invocar métodos definidos dinamicamente o cargados desde configuración 

4.3  Desventajas: 
	- Puedes romper la seguridad, ua que ".send" permite accedes tambien a métodos privados.
	- Hace el código menos claro y más dificil de depurar. 
	- Puede ar errores en tiempo de ejecución si el método no existe.ch

4.4 Ejemplo en producción 
	urls produccion de rails:	
	
	https://github.com/rails/rails/blob/main/activemodel/lib/active_model/attribute_methods.rb

	En el repositorio oficial de Rails, .send se usa en varios lugares. Un caso muy claro está 
	en ActiveRecord, donde se utiliza para establecer atributos de modelos dinámicamente.

	Código:
	rails/rails – activemodel/lib/active_model/attribute_methods.rb (línea de uso de send)

	Ejemplo de uso en Rails:

	def respond_to_without_attributes?(method, include_private = false)
		if super
			true
		else
			match = match_attribute_method?(method.to_s)
			match && attribute_method?(match.attr_name) && (!match.predicate? || self.send(match.attr_name).nil?)
		end
	end


	Aquí Rails usa .send para invocar dinámicamente el atributo correspondiente a un 
	método como user.name? o user.age?.

	En producción, esto permite que al definir un modelo así:

	class User < ApplicationRecord; end


	Puedas llamar dinámicamente:

	user = User.new(name: "Alice")
	user.name        # => "Alice"
	user.name?       # => true  (Rails internamente usa .send aquí)

-----------------------------------------------------------------------------------------------------------------
5. Describame el route de rails:
	En ruby on rails el router (archivo config/routes.rb) es el sistme que conecta las urls de la 
	aplicacion con las acciones de los controladores cuando  un usuario accede a una ruta ( por ejemplo, /users), 
	el router decide qué controlador y acci+ón manejarán esa petición.

5.1  Historia del concepto / ¿ Por qué lo inventaron ?
	El enrutador fue introducido en rails para simplicar la relacion entre URLs y controladores, siguiendo 
	la filosfia de convencion sobre configuracion . En luagar de definir manualmente el mape de URLs en cada 
	aplicacion, Rails ofrece un sistem a declarativo y legible para expresar rutas RESTfull. Con la 
	llegada de Rails 3 y 4 , se consolidó el estilo REST (representación de recursos con index, show , create, etc), 
	que sigue siendo estándar hoy.

Ejemplo:
	Un archivo routes.rb sencillo:

		Rails.application.routes.draw do
			resources :users        # crea rutas RESTful: index, show, new, edit, create, update, destroy
			get "about", to: "pages#about"
			root "home#index"       # página principal
		end

	Esto genera, por ejemplo:
		GET /users -> users#index
		GET /users/:id -> users#show
		POST /users -> users#create
		GET /about -> pages#about

5.2  Ventajas: 
	- Sintaxis declarativa.clara y concisa.
	- Soporte nativo para RESTful routes.
	- Permite rutas personliazaas y anidadas.
	- Integra helpers automaticos (user_path)

5.3  Desventajas: 
	- Puede ser complejo en aplicaciones grandes con muchas rutas 
	- Anudar demasiadas recursos vuleve el archivo dificil de manener
	- La magia de Rails puede dificultar enteder qué rutas se crean si no se domina bien "resources"

5.4 Ejemplo en producción 
	En el propio código de Rails (repositorio oficial), el sistema de 
	rutas se define en actionpack/lib/action_dispatch/routing/route_set.rb.
	rails/rails – route_set.rb en GitHub

	Dentro de Rails, el enrutador implementa el método draw que usamos en routes.rb:

	```
	def draw(&block)
		clear!
		eval_block(block)
		finalize!
	end
	```
	En una aplicación Rails real (ejemplo: GitLab repo ), el archivo config/routes.rb llega a 
	tener miles de líneas, donde definen rutas para repositorios, issues, merge requests, etc.
	Fragmento real de GitLab (Rails en producción):

	```:
	resources :projects, only: [:index, :show, :create, :update, :destroy] do
		resources :issues
		resources :merge_requests
	end
	```
	Esto genera rutas RESTful para proyectos, con rutas anidadas para issues y merge requests.



-----------------------------------------------------------------------------------------------------------------

describame la  clase router de rails en detalle: 

Este es el detalle técnico sobre la clase Router en Rails (dentro de ActionDispatch).

* ¿Dónde vive el router en Rails?

El router de Rails está implementado principalmente en el módulo ActionDispatch::Routing, especialmente en las clases:

ActionDispatch::Routing::RouteSet -> Es la clase central, contiene la lógica para definir, almacenar y reconocer rutas.

ActionDispatch::Journey -> Motor interno de parsing y matching de rutas, usado por RouteSet.

Cuando escribes en config/routes.rb:

Rails.application.routes.draw do
  resources :users
  get "about", to: "pages#about"
end


estás llamando a métodos de RouteSet::Mapper, que internamente agregan rutas al objeto RouteSet.

* Componentes clave de la clase RouteSet

Definición de rutas

Método draw(&block) -> Ejecuta el bloque que defines en routes.rb.

Crea instancias de Mapper, que a su vez generan objetos Journey::Route.

Reconocimiento de rutas

El método recognize_path(path, environment) determina qué ruta coincide con una URL dada.

Esto se usa cuando llega una petición HTTP a Rack -> Rails traduce la URL en controller#action.

Generación de helpers

Rails automáticamente genera helpers como users_path, new_user_url, etc.

Estos helpers se crean dinámicamente a partir de las rutas declaradas.

Despacho de acciones

Una vez que se reconoce la ruta, RouteSet crea un Dispatcher que llama al controlador y acción correctos.

* Flujo simplificado del router en acción

El middleware de Rack recibe la petición.

Rails pasa la URL al router (RouteSet).

El router busca una coincidencia usando Journey (una librería de expresiones regulares optimizada).

Si encuentra coincidencia:

Extrae parámetros (:id, :controller, :action).

Llama al controlador correcto mediante dispatch.

Si no encuentra coincidencia -> devuelve ActionController::RoutingError (No route matches ...).

* Ejemplo interno (código Rails)

En route_set.rb:

def recognize_path(path, environment)
  @router.recognize(path, environment) do |route, matches, params|
    params = params.merge route.defaults
    yield(route, matches, params)
  end
end


Aquí Rails:

Intenta reconocer la ruta con el motor interno @router.

Si la encuentra, fusiona parámetros por defecto (defaults) con los de la URL.

Retorna el controlador y acción adecuados.

* Idea clave

La clase Router (RouteSet) en Rails es básicamente un intérprete bidireccional de rutas:

De URL -> Acción (cuando un request llega).

De Acción -> URL (cuando usas helpers como user_path(@user)).

-----------------------------------------------------------------------------------------------------------------
6. Describame los métodos find, fin_by, where de rails. 
En ruby on rails los metodos find, find_by y whre son parte de ActiveRecord y se usan 
para consultar registros en la base de datos , pero funcionan de manera distinta.

find:
- busca un registro "por su clave primaria (id)"
- Si encuentra el registro, devuelve un objecto 
- Si no existe, lanza un excepcioon ActiveRecord::RecordNotFoundo

```ruby
User.find(1) 
# => devuelve el usuario con id = 1
```

find_by:
- Busca el primer registro que cumpla la condición 
- Si nolo encuentra. devuleve nil (no lanza excepción)
- Se usa cuando no quieres trabajar con arrays, sino con un solo objeto.

```ruby
- User.find_by(email: "test@example.com")
# => devuelve el primer usuario con ese email o nil
```

where
- Busca todos los registros que cumplan la condición.
- Devuelve una colección (ActiveRecord::Relation), que puede seguir siendo 
encadenada con más condiciones.
- Si no encuentra registros, devuelve una colección vacía, no nil.

```ruby
User.where(active: true)
# => devuelve todos los usuarios activos como colección
```

Diferencias clave:
find    -> busca solo por ID y lanza error si no existe.
find_by -> busca la primera coincidencia y devuelve nil si no encuentra.
where   -> devuelve una colección de coincidencias (aunque esté vacía).


-----------------------------------------------------------------------------------------------------------------
7. Que son los helper en rails 
	los helpers on módulos que contienen métodos diseñados para simplificar  la
	lógica de presentación en las vistas. Sirven para mantener las vistas más limpias,
	evitando escribir código Ruby complejo directamente en los archivos .erb  o .haml 

7.1  Historia del concepto / ¿ Por qué lo inventaron ?
	Los helpers fueron introducidos desde las primeras versiones de Rails (2004-2005) 
	por David Heinemeire Hansson. La idea era separar la lógica de negocio (modelo/controlador) de 
	la lfica de presentación (vistas) . en las vistas, muchas veces se repetía código 
	( por ejemplo formatear fechas, mostrar botonoes, contruir formulariios ),
	lo que generaba duplicacion . 

	Los helpers nacieron para centralizar esas funciones de presentación en modulos reutilizables.
	Los helpers nacieron para centralizar esas funciones de presentación en modulos reutilizables.
	Los helpers nacieron para centralizar esas funciones de presentación en modulos reutilizables.

Ejemplo: 
	Un helper básico para formatear fechas:
	```ruby
	# app/helpers/application_helper.rb
	module ApplicationHelper
		def formatted_date(date)
			date.strftme("%d/%m/%Y")
		end
	end
	```
	Y en la vista .erb:

	```ruby
	<p>Fecha de creación: <%= formatted_date(@user.created_at) %></p>
	```
7.2  Ventajas: 
	- Mantienen las vistas mas linpias y legibles 
	- Evitan duplicación de código en vistas 
	- Reutilizables en todo el proyecto (los helpers son módulos)
	- Fáciles de testear de forma aislada 
7.3  Desventajas: 
	- Si no se organiza bien , pueden convertirse en un "basurero logico " (todo mezclado)
	- Exceso de metodos en ApplicationHelper puede dificultar el mantenimiento .
	- Algunos devs considerna que abusan de los helpers en lugar de usas "decorator" o "view objects"
	lo cual puede romper la separación de responsabilidades.


7.4 Ejemplo en producción (Rails en GitHub)

	https://github.com/rails/rails/blob/main/actionview/lib/action_view/helpers/tag_helper.rb

	Rails trae helpers nativos en su propio código. Un ejemplo real es el módulo TagHelper
	 en el core de Rails:

	```ruby

		module ActionView
			module Helpers
				module TagHelper
					def content_tag(name, content_or_options_with_block = nil, options = nil, escape = true, &block)
						...
					end
				end
			end
		end

	```
	Este helper (content_tag) permite generar etiquetas HTML en las vistas de Rails de forma sencilla:

	```ruby
		<%= content_tag(:p, "Hola mundo", class: "greeting") %>
	```


	Produce:

	```ruby
		<p class="greeting">Hola mundo</p>
	```


	Fuente en producción: rails/actionview/helpers/tag_helper.rb


-----------------------------------------------------------------------------------------------------------------
8. Que es Api-Pagination en Ruby on Rails ? 
8.1  Historia del concepto / ¿ Por qué lo inventaron ?
8.2  Ventajas: 
8.3  Desventajas: 
8.4 Ejemplo en producción 

# Api-Pagination en Ruby on Rails

## Concepto

`api-pagination` es un gem para Ruby on Rails que facilita la implementación de paginación en APIs. En lugar de incluir 
información de paginación en el cuerpo de la respuesta, lo hace en los encabezados HTTP, siguiendo el 
estándar [RFC-8288](https://www.rfc-editor.org/rfc/rfc8288.html). Esto permite una comunicación más eficiente entre el 
servidor y el cliente, especialmente en aplicaciones que consumen grandes volúmenes de datos.

## Historia del concepto / Por qué lo inventaron

La necesidad de paginación en APIs surgió con el aumento de aplicaciones que manejan grandes cantidades de datos. 
Incluir toda la información en una sola respuesta puede sobrecargar tanto al servidor como al cliente. `api-pagination` 
fue creado para mejorar el rendimiento y la escalabilidad de las aplicaciones Rails, moviendo la información de paginación 
a los encabezados HTTP.

## Ejemplo

Instalación de los gems necesarios:

```ruby
gem 'api-pagination'
gem 'pagy' # o 'kaminari', 'will_paginate'
```

En el controlador:

```ruby
include ApiPagination::Rails

def index
  @posts = Post.page(params[:page]).per(10)
  render json: @posts
end
```

Esto genera encabezados como `X-Total`, `X-Per-Page` y `X-Page`, proporcionando información sobre la paginación sin 
sobrecargar el cuerpo de la respuesta.

## Ventajas

* **Eficiencia:** Reduce la carga en el cuerpo de la respuesta al mover la información de paginación a los encabezados.
* **Compatibilidad:** Funciona con Rails API y Grape.
* **Configurabilidad:** Compatible con `pagy`, `kaminari` o `will_paginate`.
* **Cumplimiento de estándares:** Sigue el estándar RFC-8288 para enlaces web.

## Desventajas

* **Dependencias adicionales:** Requiere instalar gemas como `pagy`, `kaminari` o `will_paginate`.
* **Complejidad en la configuración:** Puede necesitar ajustes en proyectos existentes.
* **Limitaciones en clientes:** Algunos clientes HTTP podrían no manejar correctamente los encabezados de paginación.

## Ejemplo en producción

Una API que devuelve una lista de productos puede usar `api-pagination` para paginar los resultados. Esto reduce el 
tiempo de respuesta y la carga en el servidor. La información de paginación en los encabezados permite al cliente navegar 
entre páginas sin procesar grandes cantidades de datos de una sola vez.

-----------------------------------------------------------------------------------------------------------------
9. Que es "RFC 8288 standard " ? 
9.1  Historia del concepto / ¿ Por qué lo inventaron ?
9.2  Ventajas: 
9.3  Desventajas: 
9.4 Ejemplo en producción 


```markdown
# RFC 8288

## Concepto
El RFC 8288 define un estándar para los encabezados HTTP conocidos como `Web Linking`. Este estándar especifica cómo representar enlaces en las respuestas HTTP usando el encabezado `Link`, permitiendo a los servidores indicar relaciones entre recursos web de manera estructurada y estandarizada.

## Historia del concepto / Por qué lo inventaron
El estándar se desarrolló para proporcionar una forma uniforme de describir relaciones entre recursos web sin incrustarlas directamente en el contenido HTML. Antes, los enlaces podían ser ambiguos o depender de convenciones propias de cada sitio. RFC 8288 unifica esto, facilitando automatización, descubrimiento de APIs y navegación semántica entre recursos web. Fue publicado en marzo de 2017 como actualización de estándares previos de Web Linking (RFC 5988).

## Ejemplo
En una respuesta HTTP, un servidor puede enviar:

```

Link: [https://api.example.com/users?page=2](https://api.example.com/users?page=2); rel="next",
[https://api.example.com/users?page=34](https://api.example.com/users?page=34); rel="last"

```

Esto indica que el recurso actual tiene un enlace al siguiente conjunto de usuarios y al último conjunto.

## Ventajas
- Permite describir relaciones entre recursos sin modificar el contenido principal.
- Facilita paginación de APIs, descubrimiento de recursos y automatización.
- Estandarizado y ampliamente adoptado en APIs RESTful y servicios web.

## Desventajas
- Puede ser ignorado si el cliente no implementa soporte para Web Linking.
- La sintaxis puede volverse compleja si se necesitan muchos enlaces con múltiples parámetros.
- No reemplaza la semántica de enlaces en HTML; es complementario.

## Ejemplo en producción
Muchas APIs RESTful modernas, como GitHub API o Stripe API, usan RFC 8288 para la paginación de resultados:
- `Link` en encabezados indica `next`, `prev`, `first` y `last`.
- Clientes pueden leer los enlaces y navegar automáticamente a la página siguiente sin analizar el contenido JSON.
```





-----------------------------------------------------------------------------------------------------------------
10. Que es "num " como modulo en ruby y ruby on rails   ? 
10.1  Historia del concepto / ¿ Por qué lo inventaron ?
10.2  Ventajas: 
10.3  Desventajas: 
10.4 Ejemplo en producción 

# Num como Módulo en Ruby y Ruby on Rails

## Concepto

En Ruby, `Numeric` es la clase base de todos los números, y `num` no es un módulo nativo, pero comúnmente se refiere a métodos y funcionalidades relacionadas con números. Algunos desarrolladores crean módulos llamados `Num` para agrupar métodos auxiliares de operaciones numéricas o validaciones dentro de proyectos Ruby o Rails.

## Historia del concepto / Por qué lo inventaron

Ruby es un lenguaje orientado a objetos, y cada tipo de dato es un objeto. La clase `Numeric` y sus subclases (`Integer`, `Float`, `Rational`, `Complex`) existen desde el inicio de Ruby para manejar tipos numéricos. Los módulos personalizados como `Num` se crean para mantener el código organizado y reutilizable, especialmente en Rails, donde se busca encapsular lógica de negocio y utilidades que manipulan números.

## Ejemplo

```ruby
# Definición de un módulo Num en Ruby
module Num
  def self.sumar(a, b)
    a + b
  end

  def self.potencia(base, exponente)
    base ** exponente
  end
end

# Uso del módulo
puts Num.sumar(5, 3)        # => 8
puts Num.potencia(2, 3)      # => 8
```

En Rails, un módulo `Num` podría ubicarse en `app/lib/num.rb` para ser utilizado en distintos modelos o controladores.

## Ventajas

* Reutilización de código.
* Organización de funcionalidades relacionadas con números.
* Facilita mantenimiento y pruebas unitarias.
* Evita duplicación de lógica en múltiples lugares.

## Desventajas

* Puede generar confusión si se usa el mismo nombre que clases nativas.
* Si no se documenta bien, otros desarrolladores podrían no entender su propósito.
* Puede crecer demasiado si se agregan muchas funciones, convirtiéndose en un módulo demasiado genérico.

## Ejemplo en producción

En una aplicación Rails para finanzas, podrías tener un módulo `Num` que incluya métodos para cálculos de intereses, redondeos personalizados, conversión de divisas, etc., que luego serían usados en modelos como `Transaction` o `Account`:

```ruby
module Num
  def self.redondear(valor, decimales = 2)
    (valor * (10 ** decimales)).round.to_f / (10 ** decimales)
  end
end

# En un modelo Rails
class Transaction < ApplicationRecord
  def monto_redondeado
    Num.redondear(self.amount)
  end
end
```


-----------------------------------------------------------------------------------------------------------------
11. Que es "Operator overloading " en ruby ? 
11.1  Historia del concepto / ¿ Por qué lo inventaron ?
11.2  Ventajas: 
11.3  Desventajas: 
11.4 Ejemplo en producción 

-----------------------------------------------------------------------------------------------------------------
_. Que es "Operator overloading " en ruby ? 
_.1  Historia del concepto / ¿ Por qué lo inventaron ?
_.2  Ventajas: 
_.3  Desventajas: 
_.4 Ejemplo en producción 

-----------------------------------------------------------------------------------------------------------------
_. Que es "Operator overloading " en ruby ? 
_.1  Historia del concepto / ¿ Por qué lo inventaron ?
_.2  Ventajas: 
_.3  Desventajas: 
_.4 Ejemplo en producción 

-----------------------------------------------------------------------------------------------------------------
_. Que es "Operator overloading " en ruby ? 
_.1  Historia del concepto / ¿ Por qué lo inventaron ?
_.2  Ventajas: 
_.3  Desventajas: 
_.4 Ejemplo en producción 

-----------------------------------------------------------------------------------------------------------------
_. Que es "Operator overloading " en ruby ? 
_.1  Historia del concepto / ¿ Por qué lo inventaron ?
_.2  Ventajas: 
_.3  Desventajas: 
_.4 Ejemplo en producción 

```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
```ruby```
