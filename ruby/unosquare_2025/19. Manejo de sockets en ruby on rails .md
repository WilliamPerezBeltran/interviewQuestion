
-----------------------------------------------------------------------------------------------------------------
19. Manejo de sockets en ruby on rails 
19.1  Historia del concepto / ¿ Por qué lo inventaron ?
19.2  Ventajas: 
19.3  Desventajas:
19.4 Ejemplo en producción 

# Manejo de Sockets en Ruby on Rails

## Concepto

Los sockets en Ruby on Rails permiten la comunicación bidireccional en tiempo real entre el servidor y los clientes mediante WebSockets. Esto significa que el servidor puede enviar datos al cliente sin que este tenga que hacer una solicitud explícita, y viceversa. Es especialmente útil para aplicaciones como chats, notificaciones instantáneas, dashboards interactivos, colaboración en tiempo real, y juegos en línea.

## Historia del concepto / Por qué lo inventaron

El concepto de sockets en computación se desarrolló para permitir la comunicación directa entre aplicaciones a través de la red. Antes de Rails 5, los desarrolladores tenían que integrar soluciones externas como Faye o Pusher para habilitar la comunicación en tiempo real. Con Rails 5, se introdujo **Action Cable**, una integración nativa de WebSockets que permite a los desarrolladores crear aplicaciones interactivas en tiempo real usando la misma pila de Rails, manteniendo la coherencia con la arquitectura MVC y el manejo de conexiones y canales de manera más sencilla.

## Ejemplo

### Canal en Rails

```ruby
# app/channels/chat_channel.rb
class ChatChannel < ApplicationCable::Channel
  def subscribed
    # Cuando un usuario se suscribe, se conecta al canal correspondiente
    stream_from "chat_#{params[:room]}"
  end

  def unsubscribed
    # Limpieza de recursos si se desconecta el usuario
  end

  def send_message(data)
    # Transmitir un mensaje a todos los suscriptores del canal
    ActionCable.server.broadcast "chat_#{params[:room]}", message: data['message'], user: current_user.name
  end
end
```

### Conexión del cliente

```javascript
// app/javascript/channels/chat_channel.js
import consumer from "./consumer"

const chatChannel = consumer.subscriptions.create({ channel: "ChatChannel", room: "general" }, {
  received(data) {
    // Mostrar mensaje recibido en la interfaz
    const chatBox = document.getElementById('chat-box')
    const messageElement = document.createElement('p')
    messageElement.textContent = `${data.user}: ${data.message}`
    chatBox.appendChild(messageElement)
  },

  sendMessage(message) {
    // Enviar mensaje al servidor
    this.perform('send_message', { message: message })
  }
})
```

## Ventajas

* Comunicación en tiempo real y bidireccional.
* Integración nativa con Rails a través de **Action Cable**.
* Facilita la creación de aplicaciones interactivas sin depender de librerías externas.
* Manejo de múltiples canales y usuarios con facilidad.
* Compatible con la arquitectura MVC y patrones de Rails.

## Desventajas

* Mayor carga en el servidor con muchos clientes conectados simultáneamente.
* Escalabilidad limitada sin usar soluciones externas como Redis para manejar múltiples servidores.
* No adecuado para transmisión de grandes volúmenes de datos continuos como video o audio en tiempo real.
* La configuración de seguridad y autenticación de canales puede ser compleja en proyectos grandes.

## Ejemplo en producción

* **Basecamp**: utiliza Action Cable para notificaciones en tiempo real y actualizaciones de tareas.
* **GitHub**: actualizaciones de issues y pull requests en tiempo real sin recargar la página.
* **Aplicaciones de chat en Rails**: permiten que los mensajes se transmitan instantáneamente entre todos los usuarios conectados a un canal específico.

