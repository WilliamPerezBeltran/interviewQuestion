-----------------------------------------------------------------------------------------------------------------
4. Que es class.send en ruby -> le metodo .send 
	En ruby .send permite invocar dinamicamente un mpetodo de un objecto, 
	incluso aunque el nombre método se pase como símbolo o cadena. Esto 
	significa que puedes ejecutar un método cuyo nombre no conoce hasta tiempo de ejecución.

	```ruby
	"hello".send(:uppercase) -> HELLO
	```

4.1  Historia del concepto / ¿ Por qué lo inventaron ?
	El mpetodo ".send" fue introducido en ruby como parte de sus capacidades de metaprogramacion.
	Ruby está diseñdo para ser muy flexible , y ".send" permite llamar métodos de forma dinámica, 
	lo que resulta útil en casos como frameworks web (Rails, Sinatr) que dependen de nombres de 
	metodos definidos por convenciones o generadores en runtime.

	Ejemplo: 

	```
	class User
		def greet
			"hi"
		end
	end
	u = User.new
	puts u.send(:greet) -> hi
	```

	Tambien puede usersar con argumentos: 

	```
	class MathOps
		def multiply(a,b)
			a*b
		end
	end
	m = MathOps.new
	puts m.send(:multiply,2,3) # -> 6
	```
4.2  Ventajas: 
	- Permite flexibilidad extrema en la invocación de étodos
	- Facilita metaprogramación y DSLs( Domain Specific LAnguages)o
	- Util para invocar métodos definidos dinamicamente o cargados desde configuración 

4.3  Desventajas: 
	- Puedes romper la seguridad, ua que ".send" permite accedes tambien a métodos privados.
	- Hace el código menos claro y más dificil de depurar. 
	- Puede ar errores en tiempo de ejecución si el método no existe.ch

4.4 Ejemplo en producción 
	urls produccion de rails:	
	
	https://github.com/rails/rails/blob/main/activemodel/lib/active_model/attribute_methods.rb

	En el repositorio oficial de Rails, .send se usa en varios lugares. Un caso muy claro está 
	en ActiveRecord, donde se utiliza para establecer atributos de modelos dinámicamente.

	Código:
	rails/rails – activemodel/lib/active_model/attribute_methods.rb (línea de uso de send)

	Ejemplo de uso en Rails:

	def respond_to_without_attributes?(method, include_private = false)
		if super
			true
		else
			match = match_attribute_method?(method.to_s)
			match && attribute_method?(match.attr_name) && (!match.predicate? || self.send(match.attr_name).nil?)
		end
	end


	Aquí Rails usa .send para invocar dinámicamente el atributo correspondiente a un 
	método como user.name? o user.age?.

	En producción, esto permite que al definir un modelo así:

	class User < ApplicationRecord; end


	Puedas llamar dinámicamente:

	user = User.new(name: "Alice")
	user.name        # => "Alice"
	user.name?       # => true  (Rails internamente usa .send aquí)
